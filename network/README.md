# Network

## ❓주소창에 www.google.com을 입력하면 일어나는 일에 대해 설명해 주세요.

웹 브라우저에 해당 도메인 주소를 입력시 과정은 크게 13단계로 나뉘며,

1~5단계는 데이터 받아오는 과정

6~12단계는 웹 브라우저에 렌더링 되는 과정으로 설명을 구분했다.

### 데이터 받아오는 과정

1. `www.google.com`**을 입력하면 입력한 URL 주소 중, 도메인 이름에 해당하는 google.com을 DNS 서버에서 검색합니다.**

   웹 브라우저는 DNS 서버에 검색하기 전에 캐싱된 DNS 기록들을 먼저 확인합니다.

   만약 해당 도메인 이름에 맞는 IP 주소가 존재하면, DNS 서버에 해당 도메인 이름에 해당하는 IP주소를 요청하지 않고 캐싱된 IP주소를 바로 반환합니다. 일치하는 IP주소가 존재하지 않는다면, 다음 과정인 DNS 서버 요청으로 넘어갑니다.

2. **가장 가까운 DNS 서버에서 해당 도메인 이름에 해당하는 IP주소를 찾아 사용자가 입력한 URL 정보와 함께 전달을 합니다.**

   DNS서버가 호스팅하고 있는 서버의 IP주소를 찾기 위해 DNS query를 전달합니다.

   DNS query는 현재 DNS서버에 원하는 IP주소가 존재하지 않으면 다른 DNS 서버를 방문하는 과정을 원하는 IP주소를 찾을 때까지 반복합니다.

   해당 도메인 이름에 맞는 IP주소로 변환하는 과정은 점(.)을 기준으로 계층적으로 구분하여 구성이 됩니다. 해당 계층의 탐색 순서는 뒤에서부터 해당 도메인 이름에 맞는 지역 DNS를 탐색하며, root DNS 서버가 나올때까지 거꾸로 탐색합니다.

   > Ex) . -> com -> google.com

   이와 같이 Local DNS 서버가 여러 DNS 서버를 차례대로 물어봐서 답을 찾는 과정을 Recursive Query라고 부릅니다.

3. **전달받은 IP주소를 이용하여 웹 브라우저는 웹 서버에게 해당 웹 사이트에 맞는 html문서를 요청합니다**

   해당 HTTP 요청 메세지는 [TCP/IP 프로토콜](https://velog.io/@tnehd1998/OSI-7-Layer-TCPIP-4-Layer)을 사용하여 서버로 전송됩니다. TCP는 전송 제어 프로토콜로 데이터의 전송을 제어하고 데이터를 어떻게 보낼 지, 어떻게 맞출 지 정합니다. IP의 특징인 비신뢰성과 비연결성으로 인해 IP 프로토콜 만으로는 통신을 할 수 없습니다. 그렇기에, 신뢰성과 연결성을 책임지는 TCP를 활용하여 통신을 합니다.

   TCP는 3 way handshake 과정을 통해

   연결 및 데이터를 수신받고,

   4 way handshake 과정을 통해

   연결을 종료합니다.

   3 way handshake의 과정

   - A 클라이언트는 B 서버에 접속을 요청하는SYN 패킷을 전송합니다.
   - B 서버는 SYN 요청을 받고A 클라이언트에게 요청을 수락한다는SYN_ACK flag가 설정된 패킷을 전송합니다.
   - A 클라이언트는 B 서버에게 ACK를 전송 후,연결이 이루어지고 데이터가 오고 가게 됩니다.

   !https://velog.velcdn.com/images/tnehd1998/post/53f1170d-7f07-4046-9102-37d92cbbe6ef/image.png

   4 way handshake 과정

   - 클라이언트가 연결을 종료하겠다는FIN플래그를 전송합니다.
   - 서버는 확인메세지 ACK를 보낸 후,자신의 통신이 끝날 때까지 기다립니다.
   - 서버의 통신이 끝났으면연결이 종료되었다고클라이언트에 FIN 플래그를 전송합니다
   - 클라이언트는 확인했다는 메세지 ACK를 보냅니다.
     > 만약, Client에서 세션을 종료시킨 뒤 도착하는 패킷이 있다면해당 패킷은 Drop되고 데이터는 유실되게 됩니다.이러한 현상을 위해Client는 Server로부터 FIN을 수신하더라도일정시간동안 세션을 남겨놓고 잉여 패킷을 기다리는TIME_WAIT과정을 마지막으로 거치게 됩니다.

   !https://velog.velcdn.com/images/tnehd1998/post/1077f152-2640-46fd-9fed-3074794ae123/image.png

   ### 4. WAS와 데이터베이스에서 웹페이지 작업을 처리합니다.

   웹 서버 혼자서 모든 로직 처리 및 데이터 관리를 하게되면

   서버에 과부하가 일어날 가능성이 높습니다.

   그렇기에 서버의 일을 돕는 조력자 역할을 하는 것이 WAS입니다.

   WAS는 사용자의 컴퓨터나 장치에 웹 어플리케이션을 수행해주는 미들웨어 입니다.

   특정 데이터 요청을 브라우저로부터 받게되면,

   웹 서버는 페이지의 로직이나 데이터베이스의 연동을 위해

   WAS에게 이들의 처리를 요청합니다.

   WAS는 해당 요청을 통해 동적인 페이지 처리를 담당하고,

   DB에서 필요한 데이터 정보를 받아 그에 맞는 파일을 생성합니다.

   > 웹 서버 : 정적인 파일(HTML, CSS, 이미지 파일)을 처리
   > WAS : 동적인 파일(JS, TS)을 처리

   !https://velog.velcdn.com/images/tnehd1998/post/2d477145-dfd1-4f8e-9c8d-bfdb57d0acf5/image.png

   ### 5. WAS에서의 작업 처리 결과들을 웹 서버로 전송하고, 웹 서버는 웹 브라우저에게 html 문서 결과를 전달합니다.

   전달 과정에서 status code를 통해

   서버 요청에 따른 결과 및 상태를 전달합니다.

   > 1xx : 정보가 담긴 메세지
   > 2xx : response 성공
   > 3xx : 클라이언트를 다른 URL로 리다이렉트
   > 4xx : 클라이언트 측에서 에러 발생
   > 5xx : 서버 측에서 에러 발생

   `브라우저 렌더링 과정`

   ### 6. Critical Rendering Path를 통해 웹 브라우저 화면에 웹 페이지 내용을 출력

   웹 브라우저에 출력되는 단계를 Critical Rendering Path라고 하며 크게 6단계로 분류된다.

   성능 최적화하려면 수신받은 HTML, CSS, JS 파일들을 어떤 단계를 거쳐 일어나는지를 파악한 후, 해당 과정들을 최소화하는 것이 중요하다.

   ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8549e2b0-87c5-4b6f-8e89-bcea50d3d49f/fa559f0c-cb4b-40db-850f-3d64b9dae6ab/Untitled.png)

   ### 7. DOM 트리 빌드

   이전 단계에서 통신을 통해 받아온 HTML 파일들은 바이트 형태로 전달되게 되게 된다.

   바이트 → 문자 → 토큰 → 노드 → 객체 모델로 전환하는 작업이 수행된다.

   ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8549e2b0-87c5-4b6f-8e89-bcea50d3d49f/f9f7a75c-b335-4cd4-8e73-51e9c0f0f22c/Untitled.png)

   1. 변환 (바이트 → 문자)

   - 바이트 형태의 파일을 지정된 인코딩에 따라 개별 문자로 변환한다.

   1. 토큰화 과정 (문자 → 토큰)

   - “<” 문자를 만나면 상태를 태그 열림으로 변하고, 이후 만나는 a~z의 문자들은 “>” 문자를 만날때까지 태그 이름의 상태로 인식하게 된다.
   - ">" 문자를 만난 후, 현재 토큰을 발행되고 상태는 다시 자료로 돌아갑니다.
   - 이후 문자들을 소비하면서 문자 토큰이 생성되고 해당 과정은 "<" 문자를 만날 때까지 진행됩니다.
   - "<" 문자에 만나면 다시 태크 열림 상태로 변합니다.
     "/" 문자는 종료 태그 토큰을 생성하며 태그이름 상태로 변경됩니다.
     해당 상태는 ">" 문자를 만날때까지 유지됩니다.
   - 해당 과정을 모든 파일의 자료를 확인할 때까지 반복합니다.

   ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8549e2b0-87c5-4b6f-8e89-bcea50d3d49f/57803198-6ac8-4e06-9bb0-8f30d04365ec/Untitled.png)

   1. 렉싱 (토큰 -> 노드)

   - 생성된 토큰들을규칙 및 속성에 맞는 객체로 변환시킵니다.

   1. DOM 생성 (노드 -> 객체 모델)

   - 생성된 객체는 트리 데이터 구조로 연결이 됩니다.
   - 해당 트리 데이터 구조는 원래 마크업에서 정의된상위-하위 관계도 포함이 됩니다.

   해당 프로세스의 최종 출력은 DOM이며,

   해당 형태가 트리 형태를 띄고 있기 때문에

   DOM Tree라고도 부릅니다.

   ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8549e2b0-87c5-4b6f-8e89-bcea50d3d49f/95c8026f-68b3-4e73-928f-e8e63b99eeea/Untitled.png)

   ### 8. CSSOM 트리 빌드

   HTML에서 사용했던 객체 모델로 전환하는 작업이 CSS 파일에 똑같이 적용된다.

   CSSOM 트리 형태를 만듦으로써 특정 객체에 최종 스타일로 계산할 때 상위 객체의 스타일을 하향식 규칙을 저굥하는 방식으로 계산되는 스타일을 재귀적으로 세분화하게 된다.

   ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8549e2b0-87c5-4b6f-8e89-bcea50d3d49f/ee616fab-2590-4487-adc1-ee186ff7efa7/Untitled.png)

   ### 9. Render Tree 생성

   기존에 제작된 DOM과 CSSOM을 결합하여 Render Tree를 생성한다.

   Render Tree는 렌더링에 필요한 노드만 선택하여 페이지를 렌더링하는데 사용한다.

   Render Tree가 만들어지는 과정을 간단히 말하면, Document객체부터 각 노드를 순회하면서 각각에 맞는 CSSOM을 찾아서 규칙을 적용한다. 그러면서 렌더와 관련되 요소들은 렌더 트리에 포함시키게 된다.

   meta 태그나 display:none 속성을 가진 요소들은 렌더와 관련이 없으므로 포함되지 않음

   ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/8549e2b0-87c5-4b6f-8e89-bcea50d3d49f/e3f6a5f3-903f-46b9-885b-d5fb12c54d78/Untitled.png)

   ### 10. Layout (Reflow)

   Render Tree의 노드들에 대해서 뷰포트 내에서 요소들에 정확한 위치와 크기를 계산하는 단계이다. 페이지 상에 존재하는 객체의 크기를 렌더링 트리의 루트부터 시작하여 모든 객체의 정확한 위치와 크기를 계산한다.

   css에서 %나 em과 같은 상대적인 단위를 사용했을 때에는 뷰포트에 맞춰서 픽셀 단위로 변환된다.

   ### 11. Paint (Repaint)

   Layout 과정에서 렌더링 엔진이 각 요소들이 어떻게 생겼고 어떻게 보여줄지 알게 되면 화면에 실제 px로 변환하는 과정을 거친다.

   계산된 값들을 기반으로 화면에 필요한 요소들인 텍스트 이미지들이 실제로 그리는 작업을 실행한다.

   레이아웃 단계에서 계산된 모든 위치, 크기를 실제 픽셀로 변환하여 화면에 출력한다.

   11-1. Reflow & Repaint

   특정 액션과 이벤트에 따라 html의 요소와 크기나 위치의 크기를 변경해야 하는 경우가 발생하며 해당 과정을 reflow라고 한다.

   - 해당 과정이 발생하면 렌더링 트리와 각 요소들의 크기와 위치를 다시 계산해야 한다.
   - reflow에 따라 다시 페인팅을 해줘야 하는 repaint 단계 역시 수행된다.

   하지만, reflow가 발생해야 repaint가 발생하는 것이 아닌 레이아웃에는 영향을 주지 않지만, 다시 페인팅을 해야하는 background-color, visibility와 같은 스타일을 변경할 때는 독단적으로 수행된다.

   Reflow와 Repaint를 최대한 줄여야 해당 과정들을 다시 거치지 않기에 가능한 과정을 최소한으로 고려해야 성능 최적화와 연결된다.

   ### 12. Composition

   Layout과 Paint를 수행하지 않고 레이어의 합성만 실행시키는 단계이다.

   Transform, opacity와 같은 요소들을 의미한다.

   ### 13. 화면이 웹 브라우저에 출력된다.
