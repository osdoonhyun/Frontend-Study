# CS

## ❓함수형 프로그래밍에 대해 설명해주세요.

### 개념

함수형 프로그래밍은 코드의 가독성, 테스트 용이성, 병렬 처리 등을 향상시키는 데 도움을 줍니다. (하지만 사람마다 주관적으로 견해가 다를 수 있다. ex 가독성이 좋지 않다.)

### 함수형 프로드래밍의 특징

**1. 순수함수**

- 순수 함수는 프로그램의 변화 없이 입력 값에 대한 결과를 예상 할 수 있어 테스트가 용이하다.
- 동일한 input에는 항상 동일한 output 반환
- 함수의 실행이 프로그램의 실행에 영향을 미치면 안된다.
- 함수 내부에서 인자 값을 변경하거나 프로그램 상태를 변경하는 Side Effect가 없어야한다.

**2. 불변성**

- 함수형 프로그래밍에서의 데이터는 변하지 않는 불변성을 유지해야 한다.
- 데이터의 변경이 필요한 경우, 원본 데이터 구조를 변경하지 않고 그 데이터의 복사본을 만들어서 그 일부를 변경하고, 변경한 복사본을 사용해 작업을 진행한다.

**3. 선언형 함수**

- "무엇을" 할 것인가에 주목한다. 이로써 "어떻게" 하는 것에 비해 코드의 목적성을 더 명확하게 표현할 수 있다.

**4. 일급 객체와 고차함수**

- 함수를 변수나 데이터 구조안에 담을 수 있다.
- 함수를 파라미터로 전달 할 수 있다.
- 함수를 반환값(return value)으로 사용할 수 있다.
- 함수를 할당에 사용된 이름과 관계없이 고유한 구별이 가능하다.
- 동적으로 프로퍼티 할당이 가능하다.
- 함수를 인자로써 전달 할 수 있어야 한다.
- 함수의 반환 값으로 또 다른 함수를 사용 할 수 있다

**5. 재귀**

- 함수형 프로그래밍에서는 재귀를 많이 사용한다. 재귀는 자기 자신을 호출하는 함수로, 반복문 대신 사용되어 복잡한 알고리즘을 간단하게 구현할 수 있다.

## ❓CI/CD에 대해 설명해 주세요.

- **Continuous Integration (지속적 통합)**

  - 여러 개발자가 동시에 작업할 수 있는 환경을 지향합니다. 각 개발자는 자신의 변경 사항을 정기적으로 공유 리포지토리에 통합합니다.
  - 서로 다른 개발자가 작업한 코드를 병합할 때 충돌이 발생하는 것을 방지하고, 빠른 속도로 애플리케이션을 개발할 수 있습니다.
  - 자동화된 테스트를 통해 변경 사항이 기존 코드와 충돌하는지 여부를 빠르게 확인하여 버그를 신속히 수정할 수 있습니다.

- **Continuous Delivery (지속적 서비스 제공)**

  - CI의 결과물로 얻은 유효한 코드를 자동으로 리포지토리에 릴리스합니다.
  - 이로써 운영팀은 언제든지 안전하게 프로덕션 환경에 배포할 수 있습니다.
  - 테스트 자동화와 코드 릴리스 자동화를 통해 개발자와 운영팀 간의 협력을 강화하고 배포 과정에서 발생할 수 있는 휴먼 에러를 최소화합니다.

- **Continuous Deployment (지속적 배포)**

  - 지속적 배포는 지속적 서비스 제공의 확장된 형태로, 테스트를 통과한 코드 변경 사항을 자동으로 프로덕션 환경에 릴리스합니다.
  - 이를 통해 애플리케이션 변경 사항을 더 빠르게 사용 가능하게 하고 사용자 피드백을 신속하게 반영할 수 있습니다.
  - 자동화된 배포 프로세스를 통해 운영팀의 작업 부담을 줄이고 안정적인 프로덕션 환경을 유지합니다.

## ❓CI/CD를 구축한 적이 있다면 무슨 툴을 사용했고 그 이유는 무엇이었나요?

GitHub Actions를 사용해서 구축한 적이 있습니다.  
GitHub이 제공하는 서비스이다보니 리포지토리에서 손쉽게 CI/CD 결과를 확인하고 관리할 수 있습니다. 또한, YAML 포맷을 사용하여 가독성이 높고, 이미 구현되어 있는 수많은 액션을 활용하여 간단하게 CI/CD 플로우를 작성할 수 있어서 사용했습니다.

## ❓CI/CD의 장점이 무엇인가요?

- 통합 지옥을 피하고 개발자들이 지속적으로 협업할 수 있는 환경을 제공합니다.
- 빠른 애플리케이션 제공 주기를 통해 사용자들에게 더 빠르게 가치를 제공할 수 있습니다.
- 자동화된 프로세스를 통해 프로덕션 배포의 위험을 최소화하고 안정성을 향상시킵니다.

## ❓디자인 패턴을 사용함으로써 얻는 이점에 대해 설명해 주세요.

소프트웨어 개발에서 디자인 패턴은 특정한 상황에서 자주 발생하는 문제를 해결하기 위한 일종의 설계 템플릿입니다. 이는 이미 검증된 해결책으로, 개발자들이 유사한 유형의 문제에 대해 고민하지 않고도 적용할 수 있도록 돕습니다.

- **코드의 재사용성과 확장성 향상**

  - 디자인 패턴은 이미 검증된 해결책을 제공하기 때문에, 유사한 문제에 대해 반복적으로 고민하지 않아도 됩니다. 이는 코드의 재사용성을 높이고 새로운 기능을 추가하거나 시스템을 확장할 때 유용합니다.

- **코드의 가독성과 유지보수성 향상**

  - 디자인 패턴은 일반적으로 널리 알려져 있으며, 다른 개발자들도 익숙할 가능성이 높습니다. 이로써 코드의 가독성이 향상되고, 유지보수가 더 쉬워집니다.

- **소프트웨어의 유연성과 확장성 향상**
  - 디자인 패턴은 코드를 잘 구조화하여 시스템을 유연하고 확장 가능하게 만듭니다. 적절한 패턴을 사용하면 새로운 요구사항에 빠르게 대응할 수 있습니다.

디자인 패턴은 개발자들 사이에서 공통적으로 사용되는 약속된 방식으로, 코드를 구조화하고 문제를 해결하는 데 도움을 줍니다. 코드의 효율성, 가독성, 유지보수성을 향상시키고 시스템의 유연성을 높이는데 중요한 역할을 합니다.

## ❓MVC, MVVM에 대해 설명해 주세요.

MVC와 MVVM은 소프트웨어 아키텍쳐입니다.

### MVC (Model-View-Controller):

MVC는 애플리케이션을 세 가지 주요 구성 요소로 나누어 구현합니다.

1. **Model (모델):**

   - 데이터와 비즈니스 로직을 관리합니다.
   - 사용자가 어떤 작업을 요청하면 모델은 이에 대한 응답으로 데이터를 업데이트하고, 필요한 연산을 수행합니다.

2. **View (뷰):**

   - 사용자 인터페이스를 담당합니다.
   - 모델의 상태를 시각적으로 나타내고, 사용자의 입력을 받아 컨트롤러에 전달합니다.

3. **Controller (컨트롤러):**
   - 사용자의 입력을 받아 모델을 업데이트하고, 뷰를 갱신합니다.
   - 모델과 뷰 사이의 중간 역할을 수행하여 데이터 흐름을 관리합니다.

MVC는 각 구성 요소가 서로에게 영향을 미치지 않도록 분리하여 애플리케이션을 유연하고 확장 가능하게 만듭니다.

### MVVM (Model-View-ViewModel):

MVVM은 또 다른 소프트웨어 디자인 패턴으로, 사용자 인터페이스를 만들 때 모델과 뷰를 분리합니다.

1. **Model (모델):**

   - 데이터와 비즈니스 로직을 관리합니다. MVC의 모델과 역할이 동일합니다.

2. **View (뷰):**

   - 사용자 인터페이스를 담당합니다.
   - 사용자의 입력을 받아 ViewModel에 전달하고, ViewModel에서 제공하는 데이터를 화면에 바인딩합니다.

3. **ViewModel (뷰모델):**
   - 뷰와 모델 사이의 매개체 역할을 합니다.
   - 뷰가 필요한 데이터를 모델로부터 가져와서 뷰에게 제공하며, 뷰에서 발생한 이벤트를 처리하여 모델을 업데이트합니다.

MVVM은 데이터 바인딩을 통해 뷰와 뷰모델을 연결하여, 뷰가 모델의 상태를 실시간으로 반영할 수 있게 합니다. 이로써 코드의 가독성과 유지보수성이 향상되며, UI와 비즈니스 로직의 강력한 분리가 가능해집니다.

https://careerly.co.kr/comments/61177  
https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94  
https://velog.io/@st_hwang/babwm67z#mvc-%ED%8C%A8%ED%84%B4

## ❓프론트엔드에서 MVC, MVVM 패턴을 사용하는 예시에는 무엇이 있나요?

라이브러리를 예로 들면 React Query가 MVC, React가 MVVM을 사용한다고 할 수 있습니다.

## ❓MPA, SPA, SSR, CSR에 대해 설명해 주세요.

### MPA - Multi Page Application

- 여러 개의 페이지로 구성된 애플리케이션입니다.
- 각 페이지는 일반적으로 서버에서 완전한 HTML을 받아오고, 사용자가 다른 페이지로 이동할 때마다 새로운 HTML을 서버에서 받아옵니다.
- 전통적인 웹 사이트 구조로, 각 페이지마다 새로운 요청이 발생하고 전체 페이지를 다시 렌더링합니다.

### SPA - Single Page Application

- 하나의 페이지로 구성된 애플리케이션입니다.
- 초기에 애플리케이션을 로드하면, 이후에 필요한 데이터만 받아와서 동적으로 화면을 갱신합니다.
- 일반적으로 프론트엔드에서 라우팅을 처리하고, 서버는 API 엔드포인트만 제공하는 형태입니다.
- 브라우저에서 페이지 전환이 일어나더라도 페이지 전체를 새로 불러오는 것이 아니라, 필요한 부분만 갱신하여 더 빠르게 동작할 수 있습니다.

### CSR - Client-Side Rendering

- 클라이언트 측에서 페이지 렌더링을 담당하는 방식입니다.
- 초기 로딩 시에 기본적인 HTML, CSS, 자바스크립트를 받아오고, 이후에 클라이언트 측에서 필요한 데이터를 요청하고 렌더링합니다.
- 자바스크립트 로드를 마쳐야 렌더링이 시작하기 때문에 초기 로딩 속도는 느릴 수 있지만, 이후에는 빠른 페이지 전환 및 사용자 경험을 제공할 수 있습니다.
- TTV(Time To View)가 늦지만 TTI(Time To Interaction)까지의 차이가 없습니다.
- 초기에 빈 HTML을 받아오므로 SEO 측면에서 불리합니다.
- 백오피스, 어드민 등 SEO의 중요성이 떨어지는 서비스라면 CSR이 좋은 선택지가 될 수 있습니다.

### SSR - Server-Side Rendering

- 서버에서 페이지를 렌더링하여 클라이언트에 보내주는 방식입니다.
- 사용자의 요청에 따라 서버에서 필요한 데이터를 가져와 HTML을 완전한 상태로 만들어 보내주므로, 초기 로딩 속도가 빠릅니다.
- TTV가 빠르지만 TTI까지의 차이가 존재합니다.
- 검색 엔진 최적화(SEO)에 유리하다는 장점이 있습니다.
- 서버에서 렌더링하므로 서버 자원을 소모하고 관리 포인트가 늘어난다는 단점이 있습니다.

## ❓웹페이지 최적화 도구

Google에서 제시한 성능지표인 Core Web Vital에 대해 알아보겠습니다.

**콘텐츠가 포함된 최대 페인트(LCP, Largest Contentful Pain)**

LCP는 페이지에서 핵심 요소의 콘텐츠 로딩 속도를 측정합니다.
가장 큰 요소는 보통 이미지나 동영상이다.

**첫 입력 지연(FID, First Input Delay)**

사용자가 페이지와 **처음 상호 작용(링크 클릭이나 버튼 클릭)할 때, 이에 대한 응답**으로 브라우저가 이벤트를 처리하기 까지의 시간을 측정합니다.

FID에 영향을 미치는 것은 긴 태스크, JavaScript의 실행 시간, JavaScript의 번들, 렌더 블로킹 등이 있습니다.

**누적 레이아웃 변경(CLS, Cumulative Layout Shift)**

CLS는 페이지 방문자의 시각적인 안정성을 측정합니다. 사용자에게 웹 페이지가 표시되고 최종적으로 변화되는 정도를 측정한 수치입니다.
예를 들어 `갑자기 광고나 다른 요소가 나오며 원하지 않은 요소를 클릭하는 속임수를 방지`하기 위한 척도로 쓰입니다.
