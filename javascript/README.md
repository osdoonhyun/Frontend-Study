# JavaScript

## ❓데이터 타입에 대해 설명해 주세요.

데이터 타입은 크게 메모리 상에서 저장되는 형태에 따라 기본형(Primitive) 타입과 참조형(Reference) 타입으로 나눠서 설명할 수 있다. 기본형에는 Number, String, Boolean, null, undefined, Symbol이 있고 참조형에는 대표적으로 객체가 있고 그 하위에 배열, 함수, 정규표현식, Set, Map 등이 있다.

## ❓위에서 말한 기본형과 참조형 데이터 타입에 차이점에 대해 설명해 주세요.

기본형 데이터와 참조형 데이터의 차이는 메모리 상에서 저장되는 형태에 따라 나뉘는데, 기본형의 데이터 저장 방식은 변수를 선언하고 주소를 할당하는 방식이다.
참조형은 변수를 선언하고 할당하고 나아가서 객체 안에 있는 프로퍼티를 모두 할당시킨다.

## ❓주소를 할당시키는 이유가 있는가?

데이터 할당시에 값을 직접 저장할 수 있고 값이 있는 주소를 할당시키는 방법으로 나눠서 설명할 수 있다. 둘의 장단점이 있는데, 데이터 할당시 값을 직접 저장하면 빠르지만, 값을 비교할 때 비용이 많이 들고 값이 길어지면 메모리 낭비가 심하다. 그러나 값의 주소를 저장하고 주소를 할당하면, 데이터 할당시에는 느리지만, 비교에 비용이 들지 않고 메모리 낭비를 최소화할 수 있다.

이렇게 데이터를 저장할 때 같은 값이 전체 메모리 공간 상에 오직 하나만 존재하게 되는데, 이것이 곧 불변값임을 의미한다. 그렇기 때문에 기본형 데이터에 대해서는 불변값이라 하며, 기본형 값과 참조형 값을 재할당할 경우 차이가 발생한다.
기본형 값을 바꿨을 때는 값이 바로 바뀌는 반면, 참조형을 바꿀 때는 주소를 할당하였기에 여전히 똑같은 객체를 바라본다. 객체를 복사하고 복사한 객체 값을 바꾸는데 원본 객체의 값이 같이 바뀌는 문제가 생기고 이를 해결하기 위해 매번 새로운 객체를 만들고 불변 객체가 등장하게 된 것이다.

## ❓가비지 컬렉팅에 대해 설명해 주세요.

C언어와 같은 Low-level 언어에서는 free() 함수를 통해 메모리 해제를 하지만, 자바스크립트의 경우는 메모리가 필요하지 않을 때 자동으로 해제하는데 이때 자동으로 해주는 게 가비지 컬렉터이다.

이후엔, 필요하지 않다는 기준과 어떤 원리로 가비지 컬렉션이 동작하는지에 대해, 어떤 알고리즘을 써서 메모리를 해제하는지에 대해 설명드릴 수 있습니다.

참조가 되지 않는 객체의 수인, 참조 카운트가 0이 되면 가비지 컬렉터의 수집 대상이 되어 메모리가 해제된다.

→ 이것은 순환 참조라는 문제가 있어서 이를 보완하기 위해 Mark and Sweep 방식이 나왔다. 루트에서 객체가 다른 코드에서 참조 가능한지 여부에 따라 객체의 "도달성"을 판단하여 도달 가능한 객체를 표시하고 도달 불가능한 객체를 수거하는 방식이다.

## ❓자바스크립트 객체의 속성에 대해 설명해 주세요.(writable, enumerable, configurable)

`Object.getOwnPropertyDescriptor(obj, prop);` 를 통해 객체 속성에 대한 정보를 확인할 수 있는데, 이때 객체와 객체의 속성을 인자로 넣어주면, value를 제외한 총 3개의 속성 설명을 확인할 수 있다. 3개 모두 true를 기본값으로 갖는다. `Object.defineProperty()` 를 통해 속성 설명자를 변경할수 있다.

1. writable 속성 : 해당 값을 수정할 수 있는지 여부를 나타내고 false로 설정하면
2. enumberable : 해당 객체의 속성 열거가 가능한 경우 true이고 이는 for… in Object.key() 메서드 등을 사용하여 객체 속성을 열가할 때 사용된다.
3. configurable : 해당 속성은 설정을 변경할 수 있는지 여부를 나타낸다. configurable을 false로 설정하면 설정을 변경할 수 없다.

위 3개의 객체 속성 writable, configurable, enumerable을 통해 객체의 동작을 제어할 수 있다.

## ❓ 클로져에 대해 설명해 주세요.

클로져는 본인의 상위 스코프에서 현재 참조하고 있는 식별자만을 기억한다. 이렇게 클로져에 의해 참조된 변수를 자유 변수라고 한다.

위에서 inner 함수도 outer 함수 내부에 있는 x를 참조했듯이, 클료져는 닫혀있다. 라는 의미의 클로져는 함수 본인이 기억하고 있는 자유 변수에 의해 갇혀있다. 닫혀있다. closed 되어있다는 의미다.

이 클로져는 **하나의 state가 의도치 않게 변경되지 않도록 state를 안전하게 은닉하고 또는 특정 함수에게만 state 변경을 허용하기 위해 사용된다.**

## ❓ 실행 컨텍스트에 대해 설명해 주세요.

코드를 **실행**하는데 필요한 **환경**을 제공하는 객체

- 환경 : 코드 실행에 영향을 주는 조건이나 상태
  → 코드를 실행하는데 필요한 조건이나 상태를 모아둔 객체가 바로 실행 컨텍스트이다.

실행컨텍스트는 식별자 결정에 있어서 효율적으로 해주는 수단으로서 필요한 정보를 한데 모아 제공하는 객체

실행 컨텍스트를 “코드 실행에 필요한 환경을 제공하는 객체”로 정리했고 보다 효율적인 식별자 결정을 위해 필요하다

## ❓ 자바스크립트 객체의 속성에 대해 설명해 주세요.(writable, enumerable, configurable)

`Object.getOwnPropertyDescriptor(obj, prop);` 를 통해 객체 속성에 대한 정보를 확인할 수 있는데, 이때 객체와 객체의 속성을 인자로 넣어주면, value를 제외한 총 3개의 속성 설명을 확인할 수 있다. 3개 모두 true를 기본값으로 갖는다. `Object.defineProperty()` 를 통해 속성 설명자를 변경할수 있다.

1. writable 속성 : 해당 값을 수정할 수 있는지 여부를 나타내고 false로 설정하면
2. enumberable : 해당 객체의 속성 열거가 가능한 경우 true이고 이는 for… in Object.key() 메서드 등을 사용하여 객체 속성을 열가할 때 사용된다.
3. configurable : 해당 속성은 설정을 변경할 수 있는지 여부를 나타낸다. configurable을 false로 설정하면 설정을 변경할 수 없다.

위 3개의 객체 속성 writable, configurable, enumerable을 통해 객체의 동작을 제어할 수 있다.

freeze : 값을 변경하고 추가 제거하는 것을 방지하고 싶을 때 사용

**`Object.freeze()`**를 사용하면 속성의 **`writable`**, **`enumerable`**, **`configurable`** 속성이 모두 **`false`**로 설정됩니다.

seal : 변경은 상관없고 값을 추가, 제거만 방지일 때 사용

**`Object.seal()`**을 사용하면 속성의 **`writable`**은 **`true`**로 설정되지만, **`enumerable`**와 **`configurable`**는 **`false`**로 설정됩니다.

구체적으로 object의 원리에 대해서는 공부해보지 않았지만 유추해보자면, 객체 속성을 설정 값을 변경해줌으로써 객체를 잠글 수 있지 않을까 생각됩니다.

## ❓ 이벤트 루프에 대해 설명해 주세요.

자바스크립트 **엔진**은 자바스크립트 코드를 해석하고 실행하는 인터프리터이다. (각 브라우저마다 엔진의 종류는 다르다. 사파리는 Webkit, 크롬은 V8)

<aside>
💡 **인터프리터란?**
소스 코드를 한 줄씩 읽어서 바로 실행하는 프로그램 또는 환경을 가리킵니다. 이는 컴파일러와 대비되는 개념입니다.
****자바스크립트는 주로 "스크립트 언어"로 분류됩니다. 스크립트 언어는 인터프리터(Interpreter)에 의해 한 줄씩 실행되며, 일반적으로 컴파일 단계가 없이 실행됩니다.

</aside>

자바스크립트 엔진은 크게 힙과 호출 스택(Call Stack)으로 구분이 된다.

힙 : 메모리 할당이 일어나는 부분으로 변수나 객체들이 저장되는 창고

호출 스택 : 함수가 호출되는 순서대로 쌓이는 스택 (정확히 말하면 함수가 아닌 함수의 실행 컨텍스트가 쌓이는 것)

자바스크립트는 싱글스레드 언어이다.

→ 호출 스택을 하나만 사용한다.

→ 동시에 하나의 일만 처리할 수 있다.

그럼에도 불구하고 비동기처리, 동시성에 대한 처리는 어떻게 하는 것일까?

웹 브라우저는 자바스크립트 엔진 말고도 Web API, 이벤트루프, Callback Queue를 가지고 있다.

setTimeout을 포함하여 DOM 메서드, HTTP 요청과 같은 Ajax 요청 등은 모두 자바스크립트 엔진 밖에 있는 Web API에서 제공하는 메서드들이다. WebAPI 메서드들은 작동을 마치면 비동기 메서들이기 때문에 콜백함수를 Callback Queue에 집어 넣는다. 거기서 콜백함수들이 실행을 대기하게 된다. Callback Queue는 다른 말로 **테스크큐(Task Queue)** 라고 한다.

→ 자바스크립트 엔진 자체는 싱글스레드이지만, 자바스크립트가 구동되는 환경인 웹 브라우저에는 Web API가 멀티스레드로 동작하여 여러 개의 스레드가 사용된다. 동작이 다 끝나면 Task Queue에 콜백함수를 넣어준다. 그리고 자바스크립트 엔진과 이것들이 상호 연동을 하기 위해서 필요한 장치가 Callback Queue와 Event Loop다

setTimeout는 Web API에서 실행이 되고 콜백함수를 가지고 있는 타이머를 WebAPI에서 생성하고 setTimout의 역할은 끝이 나고 return 한다. Web API에서 실행 중인 타이머가 있을 때, 정해진 시간이 지나고 나면 타이머 객체는 콜백 함수를 Callback Queue에 넣고 사라진다. 그리고 Callback Queue에서 실행되기를 기다린다. 콜백함수도 함수이기 때문에 실행되려면 호출 스택인 Call Stack에 들어가야 한다. 이때 Event Loop가 동작하게 된다.

### Event Loop

- 호출 스택과 콜백 큐를 계속 주시한다.
- **호출 스택이 비어있으면**, 먼저 들어온 순서대로 콜백 큐에 있는 콜백 함수들을 호출 스택으로 집어 넣는다.

### Callback Queue

**Callback** **Queue에 대해서 설명해 주세요.**

```jsx
console.log('시작');

setTimeout(function () {
  console.log('중간');
}, 0);

Promise.resolve().then(function () {
  console.log('promise');
});

console.log('끝');
// 시작 끝 promise 중간
```

MacroTaskQueue

- setTimeout, setInterval, Event Dispatch, networking response …
- 이벤트 루프는 MacroTaskQueue에 있는 task를 하나만 빼서 실행하고 다음 루프로 넘어간다.

MicroTaskQueue

- 어떤 일이 끝나고 처리되어야 할 일들이 다음 루프로 미뤄지는게 아니라 한번에 처리하기 위해 탄생했다. 이 Queue에 있는 MicroTask를 처리할 때는 다른 코드들이 끼지 않는다.
- Promise, MutationObserver 핸들러
- 이벤트 루프는 MicroTaskQueue가 빌때까지 task를 처리한다. 태스크 처리 중에 MicroTask가 들어와도 다음 루프로 미루지 않고 끝까지 처리한다(무한 루프 조심)
- JSEngine의 Call Stack이 비자마자 MicroTaskQueue가 가장 먼저 처리된다.
  즉 우선순위가 높다.

AnimationFrameQueue

- RequestAnimationFrame으로 등록한 콜백함수들이 이 Queue에 들어간다.
- Repaint 직전에 Queue에 있는 태스크들 전부 처리한다.
- Animation에 사용하면 frame drop을 최소화 할 수 있다.

## ❓Promise에 대해 설명해 주세요.

**Promise를 사용하는 이유**

1. 비동기적인 작업을 처리할 때, 작업이 성공했는지 실패했는지를 표준화된 방식을 이용해서 처리할 수 있도록 해준다.
2. 성공하면 then으로 전달된 함수가 실행되고, 실패하면 catch로 전달된 함수가 실행된다.

**Promise 상태**

pending : promise가 만들어져서 지정한 operation을 수행 중일 때는 pending 상태

fulfilled : operation을 성공적으로 끝내게 되면 filfilled 상태가 된다.

rejected : operation시 문제가 생긴다면 rejected 상태가 된다.

`new Promise()` 는 executor라는 콜백함수를 받는데, executor 콜백함수는 또 다른 두 가지의 콜백함수를 받는다.

resolve : 기능을 정상적으로 수행해서 마지막에 최종 데이터를 전달함

reject : 기능을 수행하다가 중간에 문제가 생기면 호출하게 될 함수

또한 executor 함수는 생성되자마자 실행이 된다. → promise는 비동기 함수이다 (X)

then, catch, finally

**Promise chaining**

then은 똑같은 promise를 리턴하기 때문에, 그 리턴된 promise에 catch를 다시 호출할 수 있다. 이를 통해 비동기적인 동작들을 묶어서 처리할 수 있다.

**Error Handling**

promise의 경우 네트워크 처리를 하는데, 네트워크에서 데이터를 받아오는 경우 시간이 걸리는데, 이러한 작업을 synchronous 동기적으로 처리하게 되면 그 시간 동안 다음 라인의 코드가 실행되지 못하기 때문에 비동기적으로 처리한다.

### promise.all , promise.race

`Promise.all` : 비동기 작업에서 가장 늦게 끝나는 작업을 기준으로 그 다음에 실행되는 방식으로 then의 파라미터는 각각의 promise에 실행 결과를 담은 배열이 반환된다.
promise 배열을 전달하게 되면 모든 promise들이 병렬적으로 받을 때까지 모아준다.

`Promise.race` : 동시에 실행시켜놓고 제일 빨리 끝나는 작업 이외의 것들은 버리고 그 다음 작업을 실행한다. then의 첫번째 파라미터로 제일 먼저 끝난 작업에 대한 결과가 전달된다.
배열에 전달되 프로미스 중에서 어떤 것이든 상관없고 먼저 리턴되는 첫 번째 promise를 받아오고 싶다.

**비동기 처리할 때 어떻게 처리하시는지?**

async/await 말고 promise를 써야 한다면 언제 쓰면 좋을지?

**await의 병렬처리 → `async/await 대신 promise를 써야할 때`**

async/await라는 키워드를 통해 비동기작업을 동기적으로 코드를 작성하듯 자연스럽게 코드를 작성하는 것처럼 간편하게 쓸 수 있다는 장점이 있다.

연관이 없는 두 개 이상의 비동기처리가 순차적으로 진행되기 때문에 비효율적이다.

```jsx
function delay(time) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      resolve(time);
    }, time);
  });
}

async function getApple() {
  await delay(2000);
  return '사과';
}

async function getBanana() {
  await delay(1000);
  return '바나나';
}

async function pickFruits() {
  const apple = await getApple();
  const banana = await getBanana();
  return `${apple} + ${banana}`;
}
pickFruits().then(console.log);

// 해결 방법 1 : promise를 만드는 순간 바로 promise 안에 있는 코드 블럭이 실행된다.
async function pickFruits() {
  const applePromise = getApple();
  const bananaPromise = getBanana();
  const apple = await applePromise; // 여기서 병렬적으로 실행됨.
  const banana = await bananaPromise;
  return `${apple} + ${banana}`;
}

pickFruits().then(console.log);
```

## ❓호이스팅에 대해 설명해 주세요.

### 호이스팅

- 호이스트는 “끌어올린다”라는 뜻입니다. 자바스크립트 코드가 실행될 때 하단에 선언된 변수나 함수가 마치 끌어올려져서 처음부터 상단에 존재했던 것처럼 동작해서 붙여진 이름입니다. 실행 컨텍스트의 생성 단계일 때, 식별자들을 환경 레코드에 미리 기록해놓기 때문에 실행 단계에서 미리 접근할 수 있게 되는 것입니다.

- 호이스팅은 Javascript에서 변수 및 함수의 선언이 스코프의 최상단으로 끌어올려지는 동작을 말합니다. 이로 인해 변수와 함수를 선언하기 전에 사용할 수 있는 것처럼 동작합니다.

- 자바스크립트는 코드를 실행하기 전에 먼저 변수와 함수를 메모리(물리적인 장소x, 논리적인 동작)에 올려놓는데, 이때 선언 부분이 코드 내에서 어디에 위치하든지에 관계없이 해당 스코프의 최상단으로 끌여올려집니다. 하지만 선언만 끌어올려지며, 초기화는 원래 위치엣 이루어집니다.

호이스팅의 예시)

```
// var로 선언된 변수
console.log(myVar); // undefined
var myVar = 10;

// 함수 선언식
myFunction(); // "Hello, world!"
function myFunction() {
  console.log("Hello, world!");
}

// 함수 표현식
myFunction1(); // TypeError: myFunction1 is not a function
var myFunction1 = function() {
  console.log("Hello, world!");
};
```

위의 코드는 사실 아래와 같이 해석됩니다.

```
var myVar;
console.log(myVar); // undefined
myVar = 10;

function myFunction() {
  console.log("Hello, world!");
}

myFunction(); // "Hello, world!"
```

## ❓원시값과 참조값의 차이점을 메모리 관점에서 설명해주세요.

두 가지 메모리 관점을 통해서 원시값과 참조값의 차이에 대해 설명할 수 있다.

1. 저장되는 메모리 영역

메모리 저장 공간으로 스택과 힙이 있다.
스택(stack)은 원시값(boolean, string, number, undefined, null, symbol)과 데이터가 존재하는 주소 등을 저장하는 메모리 공간으로, 고정된 메모리를 할당하고 이를 정적할당이라 한다. 힙(heap)은 참조값(array, function, object)을 저장하는 메모리 공간으로 메모리 할당할 때 필요한만큼 할당하고 이를 동적 메모리 할당이라고 한다.

2. 저장되는 방식

원시형의 경우, 기본적으로 변수를 선언하고 값을 할당한다. 그래서 값이 직접 변수에 저장되어 각 변수는 자체적인 메모리 공간을 갖고, 값이 저장된 메모리 주소를 직접 참조한다.
그러나 참조값의 경우, 원시형과 마찬가지로 '변수를 선언하고 할당한다'까지는 동일하고 객체 안에 있는 프로퍼티를 모두 할당시킨다. 참조형 데이터는 변수에 값이 아닌 값이 저장된 메모리 주소가 저장된다. 여러 변수가 동일한 객체를 참조할 수 있다.

기본형의 값을 바꿀 때는 값이 바로 바뀌는데, 참조형에 있는 값을 바꿀 때는 여전히 같은 객체를 바라보고 있어 값이 바뀌지 않는다. 객체를 복사하고 복사한 객체 값을 바꿨는데 원본 객체의 값이 같이 바뀌는 문제를 해결하기 위해 매번 새로운 객체를 만드는 불변 객체가 나오게 된다.

### 왜 값을 직접 저장하지 않고 주소를 저장할까?

값을 직접 저장하는 것이 데이터 할당할 때 빠를텐데 굳이 주소를 저장하는 이유가 궁금하다.
그 이유는 값이 커지거나 길어지게 된다고 했을때를 생각하면 이해하기 쉬울 것이다.

값을 직접 저장하면 데이터 할당시에는 빠르지만 값이 커지게 되면 비교에 비용이 많이 들고 저장될 때 메모리 낭비가 심하다. 그러나 값의 주소를 저장하면 데이터 할당시에는 값을 직접 저장하는 것에 비해 느리지만 값 비교시 주소만 비교하면 되니 비용이 거의 들지 않고 저장시에도 메모리 낭비를 최소화할 수 있다.

## ❓this에 대해 설명해 주세요.

**ThisBinding은 실행 컨텍스트 활성화될 때 한다.**
실행컨텍스트가 생성되는 순간에 this를 바인딩한다.

Q. 실행컨텍스트는 언제 생성되는데?

A. 컨텍스트에 해당하는 **함수가 호출되는 순간**이다. this가 함수가 호출될 때에 비로소 결정되는 것이다.

따라서 이 **함수를 어떤 식으로 호출했는지에 따라서 this는 달라진다.**
즉, 동적으로 바인딩 된다는 이야기이다.

**호출하는 방식에 따라 this가 어떻게 다른지 살펴보자.**

**전역공간에서 :**

전역 공간은 무조건 처음부터 호출이 되니 여기서의 this는 항상 정해져 있다. this는 전역 객체를 가리킨다. 브라우저에서는 window, node.js에서는 global이라는 객체이다. 왜냐면, 개념상 전역 컨텍스트를 실행하는 주체가 바로 **전역 객체**이기 때문이다. 이 전역 객체는 host 객체라고도 한다.

자바스크립트가 실행되는 환경. 즉 런타임에 따라서 전역객체의 정보가 달라진다. `window`와 `global`은 ECMAScript에서 정의한 객체가 아니고 ECMAScript가 “전역 객체는 이러이러 해야 한다”고 정의해둔 내용에 따라서 런타임에서 제공하는 구현체이다. 각 호스트 환경에서 정의한 바에 따라서 전역 객체의 구체적인 내용이 달라지는 것이다.
**“전역 공간에서의 this는 전역 객체를 가리킨다.”**는 것이다.

**함수 호출시 :**

함수 내부에서의 this는 어떻게 될까? 함수를 호출했을 때도 `전역 객체`를 가리킨다. 이 부분이 조금 헷갈리는데, 또 말이 된다. 한번 봐보자. 함수를 호출하는 순간에 이것을 실행 해 주는 주체를 보면, 호출을 그냥 a()라고 하는 함수를 호출한 거니 호출한 대상이 전역 객체가 되는 것이다.

b를 호출할 때는 주체가 전역 객체인 것은 알겠다. 그러므로 b 함수 내부에서의 this는 전역 객체이다.

c는 어떠할까? c 함수는 함수 내부에서 호출한 거니까 호출한 주체가 b라고 봐야 하지 않을까? 실제로는 여기서도 전역 객체가 나온다. 이것은 자바스크립트 창시자의 실수이다. 라는 얘기도 있다.

ECMAScript에서는 이것이 문제라는 의견을 수렴해서 this 바인딩을 하지 않는 arrow function이 나왔다. 이 **arrow function**은 바로 위 컨텍스트에 있는 this를 그대로 가져다 사용한다. 이것을 통해 문제점을 해소할 수 있었는데 ES5 환경에서는 함수로써 호출했을 때 this는 언제나 전역 객체를 가리킨다.

메서드, 객체 안에 e 라고 하는 메서드가 있고 맨 밑에서 메서드를 호출했다. 메서드로써 호출했을 때의 this는 호출한 대상 객체가 바인딩 된다는 건 뒤에 설명하고 이 메서드 안에 f라고 하는 내부함수가 또 있고 이 내부 함수를 다시 호출 했을 때, 이 경우는 함수로써 호출을 했다. 그러므로 전역 객체이다. 호출한 형태만 보면 된다.

**메서드 호출시 :**

메서드로 호출 했을 때의 this는 메서드를 호출한 주체. 메서드 명의 ‘점’ 앞에 있는 것이 this가 된다.

a.b를 호출하면 b 함수 내부에서 this를 출력한다. b 함수 내부에서의 console.log로 this를 출력했을 때의 this는 a가 되는 것이다. b라고 하는 함수는 a의 프로퍼티이다. 프로퍼티에 함수를 할당한 것이다. **b 함수를 a 객체의 메서드로써 호출**했다.

점을 기준으로 앞에 객체의 메서드로써 b를 호출했다. 메서드라는 것은 객체 지향 언어에서 어떤 인스턴스와 관련된 동작을 의미한다. 인스턴스는 사실상 어떤 클래스에 속하는 객체이므로 자바스크립트에서는 클래스가 아니더라도 객체이기만 하면 어떤 객체오 관련된 동작을 뜻하는 말로 범위를 확장시킨 것이다. 클래스의 인스턴스냐 여부와 상관없이 객체와 관련된 동작이기만 하면 메서드이다. 원래는 함수인데 이것이 어떤 객체와 관련된 동작을 하게 되면 그 때는 메서드라고 부르겠다는 것이다. 이때 어떤 객체가 바로 점 앞인 것이다.

```jsx
var a = {
  b: {
    c: function () {
      console.log(this);
    },
  },
};
a.b.c();
```

a.b.c를 호출했을때, c라는 함수 안에서 this를 호출하면 어떻게 될까? 묻지도 따지지도 않고 a.b까지가 this가 된다. c라는 함수한테 ‘a.b 라는 객체와 관련된 동작을 수행해라’ 라는 명령을 한 것이고 그러므로 this는 a.b이다.

`**‘.’`이 없는 대괄호 표기법\*\*

`‘.’` 은 대괄호 표기법으로도 표현할 수 있다. 마찬가지로 이때의 this는 obj가 된다.

> **메서드 내부함수에서의 우회법**

메서드 안에 내부함수가 있을 때 그 안에서의 this도 전역 객체를 참조하는 것이 헷갈렸는데, 이것을 우회하여 사용할 수 있다.

obj.b가 메서르소써 호출이 되었다. 여기서의 this는 obj를 가리킨다. this.a에는 20 이 나온다. 그 내부함수 function c에 대해서 그냥 c를 호출했다. 앞에 this가 없으므로 c 함수에서 내부의 this는 전역 객체를 가리킨다. 그러면 전역 객체의 a 프로퍼티를 찾아라 하는 명령인데 이때는 어떤 값이 나올까? 여기서는 10이 나온다. c를 함수로서 호출했으므로 여기서의 this는 전역 객체인데 this.a는 전역객체의 프로퍼티 a를 뜻하는데 전역 객체의 프로퍼티 a를 달라고 하니 전역 변수 a를 주는 것이다. 여기서 이상한 것은 전역 객체는 전역 객체이고, 전역 변수는 전역 변수로 서로 동떨어져 있는 별개의 개념이어야 하는데 실제로는 **전역 변수가 곧 전역 객체의 프로퍼티로 동작한다는 것**이다.

이 또한 자바스크립트의 설게상의 오류라고 얘기가 있다. 이것이 중요한 것은 아니고, 이때 여기서의 this가 전역 객체가 아니라 obj를 바라보게 하려면 어떻게 해야할까? 이때는 call, apply와 같은 명시적인 this 바인딩 명령을 쓰지 않고서는 this 자체를 직접 다른 값으로 덮어씌울 수는 없다. 기본적으로 여기서 this를 사용하면 기본적으로 전역 객체를 볼 수 밖에 없다.

다른 방법으로 **‘다른 변수를 사용하면 되지 않을까?’**라는 아이디어를 생각해볼 수 있다. **스코프체인**을 이용해서 간단하게 적용해볼 수 있다.

내부 함수보다 상위에서 self라고 하는 변수에 this를 담고 안쪽에서는 self를 쓴다. 그러면 내부 함수는 자신의 LexicalEnvironment에서 self를 찾고 없으므로 outerEnvironmentReference를 타고 외부에 있는 즉, b 함수의 LexicalEnvironment에서 self를 찾는다. 그 self에는 앞서 들어온 this가 담겨 있고 이때의 this는 obj.b를 호출할 때의 this이므로 obj를 가리킨다.
이를 통해 메서드에서와 동일한 this를 그대로 활용할 수 있게 된다. 위 방법이 반드시 self라는 변수명이 아닌 개발자들의 취향에 따라 \_this, that과 같은 변수명들이 사용되고 있다.

**ES6에서는 this를 바인딩하지 않는 arrow function이라는게 등장**하면서 이러한 우회법을 사용할 필요성이 없어졌다. this를 바인딩하지 않으므로 스코프체이닝 상의 this에 바로 접근할 수 있게 되었다. 여기서의 this는 arrow function은 this를 바인딩하지 않으므로 상위에 있는 this를 그대로 쓴다. 그래서 c에서도 똑같이 obj.a를 가리키게 돼서 20이 출력된다.

앞에 언급한 것처럼, ES5에서도 call이나 apply와 같은 방법으로도 간단하게 처리할 수 있다.

**callback 호출시 : 조금 어렵**

콜백을 호출했을 때, 기본적으로는 함수 내부에서와 동일하다.

> **call, apply, bind 메서드에 대하여 - 명시적인 this 바인딩**

[`a.call](http://a.call)(b, 1, 2, 3)`에서 this가 b를 가리키고 있고 x, y, z가 차례로 1, 2, 3이다. a.call 호출한 결과에 첫 번째 인자가 this로 넘어가고 두 번째부터는 차례대로 함수의 매개변수로 넘어간다

`a.apply(b, [1, 2, 3])`에서 첫 번째 인자가 this가 되고 두 번째 인자는 배열의 각각의 요소들이 함수의 매개변수가 된다.

a에 b를 바인드하고 그 뒤에 다시 c(1, 2, 3)을 호출하고 있다. `var c = a.bind(b);` 는 아직 함수가 호출되지 않은 상태이고 this를 들고 있는 상태로 유추해보면 `c( 1, 2, 3)` 에서 처음에 넘겨준 this를 그대로 물고 있는 상태에서 나머지 인자들이 들어갔다고 보면 된다.

`var d = a.bind(b, 1, 2)` 에서 처음에는 this와 첫 번째, 두 번째 매개변수까지 넘겨 줬지만 아직 실행은 안하고 있고 그런 상태로 별개의 bind된 함수를 만들어 놓은 상태에서 d(3)에서 호출을 한 것이다. 먼저 this와 1, 2가 들어가 있는 상태에서 다시 3을 넘김으로써 실제 함수를 호출하는게 된다.

각각의 api문서를 확인해보자. 메타 표기법으로 되어 있고 대괄호는 생략 가능하다. thisArg는 대괄호가 없으니 필수 매개변수이다. func를 호출할 때 그 안에서 ‘this는 thisArg로 인식해라’라고 개발자가 명시 하는 부분이다.

**콜백 함수에서의 this :**

obj.b에 callback 함수를 매개변수로 넘겨주었고 메서드로써 호출을 했다. 함수가 실행되는 부분인 `cb();` 만 보면 된다. 함수로써 호출을 했으므로, 여기서는 전역 객체가 나와야 한다. this는 호출될 때 결정되고 cb는 앞에 `'.'` 이 없으므로 함수로써 호출이 되었으므로 전역 객체이다.

이때 `cb.call(this);` 로 thisArg에 this를 넘기면 어떻게 될까? b 컨텍스트에서의 this는 obj이다. 그러므로 obj가 넘어가게 되므로 이때는 obj가 나오게 된다. 콜백함수 내부에서의 this는 콜백함수가 할 수 있는 것이 아닌, 콜백함수를 넘겨받는 대상, 여기서는 cb.call(this)가 넘겨받았으므로 이 대상이 매개변수로 넘겨받은 cb를 어떤식으로 처리하느냐에 따라서 this가 달라질 수 있다.

즉, **callback 함수 내부에서의 this는 기본적으로 전역 객체로 보는 것이 맞다.** 근데 obj.b라는 함수 안에서 콜백을 호출할 때, this를 ‘내가 가지고 있는 this로 할래’ 라고 지정을 했으므로 그 **지정한 값으로 바뀐다**. 그래서 **콜백함수에서의 this는 지정하는 바에 따라서 달라진다.**

**예시 보기 )**

setTimeout은 this를 별도로 처리하고 있지 않아서 0.1초 뒤에 콜백함수 내에서의 this는 전역 객체가 나온다. 임의로 setTimeout이 콜백을 처리하는 방식을 바꿀 수 없으므로 this를 원하는 값으로 지정하려면 bind를 통해 this를 지정한다.

bind가 없던 시절에는 함수를 한 번 더 감싸서 self를 이용하는 방식을 사용했다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/517372d8-f3c1-4ff1-b431-385655302f7b/Untitled.png)

클릭 이벤트에 대해서 핸들러로 콜백함수를 넘겼다. 이러면 클릭 하면 콜백함수가 실행되고 this에는 별도로 정해놓은 것이 없다면 this는 전역객체가 나온다. 근데 여기서의 this는 html dom element가 나온다. **addEventListener라는 함수가 콜백함수를 처리할 때 this는 이벤트가 발생한 그 타겟대상 엘리먼트로 하도록 정의가 되어 있다.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/39b9d673-de1e-4321-a582-6957bfc606f9/Untitled.png)

여기서도 물론 this를 obj로 하고 싶다면 `bind(obj)` 를 걸어주면 된다. 이러면 콜백함수를 넘겨줄 때 this를 obj로 하도록 명시적으로 바인딩을 해주면 this가 obj가 나온다.

> **정리**

- 기본적으로 **함수**의 this와 같다. (전역 객체 바라봄)
- **제어권을 가진 함수**가 **콜백의 this를 지정**해둔 경우도 있다.(addEventListener)
- 이 경우도 **개발자가 this를 바인딩**해서 콜백을 넘기면 그에 따른다.

**생성자 함수 호출시 :**

생성자 함수 호출시, 즉 `new 연산자`를 썼을 때는 생성자 함수의 내용을 바탕으로 인스턴스 객체를 만드는 명령이다. 이때는 새로 만들 인스턴스 객체 그 자체가 곧 this가 된다.

**함수 호출시 )**

new 연산자 없이 Person 함수를 호출할 경우 roy에는 아무것도 담기지 않고 함수로서 호출한 것이기 때문에 this는 전역 객체를 가리키게 된다. 그러므로 전역객체의 name 프로퍼티와 age 프로퍼티에 값이 할당이 된다.

**new 연산자, 생성자 함수 호출시 )**

new를 넣은채로 호출을 하면 생성자 함수로써 호출을 한 것이므로 roy라고 생긴 변수 즉, 새로 생성될 Person의 인스턴스 객체 자신이 곧 this가 되므로 객체가 새로 만들어지면서 그 객체 안에 name 프로퍼티, age 프로퍼티가 생성되고 그 객체가 다시 roy라고 하는 변수에 담기게 된다.

### 정리

**전역공간**

- 전역공간에서 this는 전역 객체를 가리킨다.

**함수 호출시**

- 함수에서도 this는 전역 객체를 가리킨다.

**메서드 호출시**

- 메서드 호출 시에는 메서드 호출 주체가 this가 된다. 보통은 점 앞이다.
- 대괄호표기법도 동일하다.

**callback 호출시**

- 콜백 호출시에는 기본적으로 함수 내부에서와 동일하게 전역 객체를 가리킨다.
- 콜백함수를 어떤 식으로 처리하는지에 따라서 this는 얼마든지 달라질 수 있다.
- 그런 경우에도 bind 명령 등을 통해서 사용자가 직접 this를 명시할 수 있다.

**생성자 함수 호출시**

- 생성자 함수 호출시에는 인스턴스가 곧 this이다.

## ❓깊은 복사 얕은 복사에 대해 설명해 주세요.

객체나 배열을 복사하는 방법을 얘기합니다. 얕은 복사는 참조 값의 복사를 나타낸다. 원본 객체의 주소값을 복사하는 것을 의미합니다.

깊은 복사는 참조 주소 값이 아닌 값을 복사하는 것을 의미합니다. 이는 원본과 참조가 끊어지기 때문에 복사된 값을 변경해도 원본 객체에 영향을 주지 않습니다.

객체 복사 연산자로는

- Object.assgin(생성할 객체, 복사할 객체)
- 전개연산자
- lodash deepclone이 있다.

```jsx
const originalObject = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(originalObject));
```

**`JSON.parse(JSON.stringify(originalObject));`**는 JavaScript 객체나 배열을 깊은 복사하는 일반적인 방법 중 하나입니다. 이 방법은 객체를 JSON 문자열로 변환하고, 다시 JSON 문자열을 파싱하여 새로운 객체를 생성하는 과정을 통해 깊은 복사를 수행합니다.

1. **`JSON.stringify(originalObject)`**: 원본 객체(**`originalObject`**)를 JSON 문자열로 변환합니다. 이 과정에서 객체의 구조가 문자열로 표현되며, 함수, undefined, 순환 참조 등은 무시됩니다.
2. **`JSON.parse(...)`**: 앞서 생성된 JSON 문자열을 파싱하여 새로운 객체를 생성합니다. 이때, 새로운 객체는 원본 객체의 모든 속성과 값들을 복사한 것이 됩니다.

`immutable.json` 도 있다.

## ❓ **`||` 와 `??` 차이에 대해 설명해 주세요.**

`||`는 0, "", false, undefined 같은 falsy 값을 전부 검사 하는 연산자고 `??`는 undefined 하고 null 같은 nullish 만 검사하는 연산자입니다.

```jsx
const a = false || "어떻게";
// a => "어떻게"
const b = false ?? "사람 이름이";
// b => false
const c = undefined ?? null ?? "엄",
// c => "엄"
```

**Q . 자바스크립트에서 `||`은 or연산도 되는데 그러면 오류가 뜰 가능성은 없나요?**

**A .**

falsy한 값이 유효하며 nullish한 값만 무효해야하는 상황이라면 쓸 수 있습니다.
0,false,true,1,2,3,"abc",... 등이 참이고 null, undefined는 거짓인 경우로 예를 들 수 있겠네요.

```jsx
const x = 0;
const y = false;
const z = {};
const a = x ?? 'hello'; // 0
const b = z.key ?? 'hello'; // hello
const c = y ?? 'hello'; // false
const aa = x || 'hello'; // hello
const bb = z.key || 'hello'; // hello
const cc = y || 'hello'; // hello
```

이런식으로 직접 해보시면 알 수 있습니다.
조건문으로 쓸 때에는
A || B 일 때에는 A가 falsy하다면 B까지 검사하지만
A ?? B 라면 A가 falsy해도 nullish하지 않다면 참이므로 B까지 검사하지 않고 조건이 참이된다

## ❓ scope chain에 대해 설명해 주세요.

- 스코프(scope)는 식별자에 대한 유효 범위를 뜻하며, 스코프 체인(scope chain)은 식별자의 유효 범위를 안에서부터 바깥으로 차례대로 검색해 나가는 것을 말합니다.
- 이를 가능하게 하는 것이 outerEnvironmentReference인데, outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조합니다. 이는 연결 리스트의 형태를 띠며, 선언 시점의 LexicalEnvironment를 계속 찾아 올라가면 마지막에 전역 건텍스트의 LexicalEnvironment가 있습니다.
- 이러한 구조적 특성때문에, 가장 가까운 요소부터 차례대로만 접근할 수 있고, 다른 순서로 접근하는 것이 불가능합니다. 즉, 여러 스코프에서 동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능합니다.

`LexicalEnvironment` : 각 식별자의 ‘데이터’를 추적하는 용도, **실시간 변화 반영 O**

**컨텍스트 내부 코드들을 실행하는 동안에 변수의 값들이 변화가 생기면** 그 값이 **LexicalEnvironment에만 실시간으로 반영**된다.

어휘적 / 사전적 환경

LexicalEnvironment를 구성하는 하위에 있는 정보들의 명칭이 좀 더 와닿는다.

environmnetRecord : 환경 기록. “현재 컨텍스트 내부의 식별자 정보”

outerEnvionmentReference : 외부 환경 참조. 문자 그대로 “ 외부 환경을 참조하는 정보”

## ❓ closure를 활용한 구현 경험에 대해 설명해 주세요.

1.  React에서 상태(State) 관리는 javascript의 클로저 개념을 활용한 패턴 중 하나입니다.
    React의 컴포넌트는 useState hook을 이용해 상태관리를 합니다. useState Hook은 클로저를 이용하여 동작하며, 이를 통해 각 컴포넌트 인스턴스마다 독립적인 상태를 가질 수 있습니다.

한 컴포넌트가 있다고 가정했을 때, 컴포넌트가 렌더링 될 때마다 '함수형 컴포넌트' 함수가 호출되지만, 해당 함수(컴포넌트) 내에서 선언된 변수들은 클로저를 통해 이전 값이 유지되고 상태 관리가 가능해집니다.
따라서 React의 상태관리는 내부적으로 클로저를 활용한 컴포넌트 간 상태를 격리하고 관리하는 기능을 제공합니다.

2.  간단한 예를 들어보자면, DOM 요소의 표시 상태를 토글을 통해 변환시키는 함수를 작성할 때, 해당 토글 함수에, 표시 상태를 나타내는 변수를 선언, 이후 해당 변수를 토글 시키는 클로저를 반환함으로써 표시 상태를 나타내는 변수를 숨기면서도, 최신 상태를 계속 유지하고, 변경될 수 있게 할 수 있습니다.

이렇게 전역변수를 사용하지 않고도, 최신 상태를 유지하고 변경또한 가능하게 하면서 코드의 의도되지 않은 변경을 예방할 수 있습니다.

실제로 리액트의 useState 또한 클로저를 통해 구현되어 있습니다. useState는 state, setState를 반환하게 되는데 해당 setState가 실행될 때 이전 상태와 현재 상태의 변경을 감지해야 하고, 그러기 위해 이전 상태를 가지고 있어야 하는데 이 곳에서 클로저가 활용됩니다.

```
const useState = (value) => {
  let saveValue = value;

  const state = () => saveValue;

  const setState = (newValue) => {
    saveValue = newValue;
  };

  return [state, setState];
};
```

**Q . 고차함수는 뭔가요?**

**A .**

고차 함수란, 함수를 파라미터로 전달받거나 연산의 결과로 반환해주는 메서드를 일컫는다. 요즘 자주 거론되는 함수형 프로그래밍의 핵심이기도 하며, 자바스크립트를 함수형 프로그래밍에 알맞은 언어로 만들어주는 특성이기도 하다.

## ❓ currying에 대해 설명해 주세요.

다중의 인자 값들을 가지는 함수를 단일에 인자값을 갖는 연속된 함수로 변환시키는 프로세스를 말한다.

f(a,b,c) → f(a)(b)(c) : 사용하려는 인자의 갯수만큼 함수로 분해를 해서 분해된 함수에 각각 순서대로 인자를 전달해서 함수열로 만들어주는 것이다.

일반함수는 인자들이 모두 전달되어야 함수가 실행되는데, 커링 함수는 한 번에 하나의 인자를 전달하고 하나의 함수를 독립적으로 실행하는 구조기 때문에 인자들을 한꺼번에 제공하지 않아도 된다.
→ 인자를 담고 있는 함수의 재사용이 가능하고 함수를 전달하는 과정에서 활용할 수 있다.

> **정리**

Currying이라는 개념은 다중의 인자값 다항의 성질을 가진 함수를 단일의 인자를 사용하는 함수들의 함수열로 변환시켜주는 것을 말한다. `Clousre`를 통해 외부 환경에 값들에 접근 가능하다. Currying을 사용할 때 인자 일부를 고정시킨 후 새로운 함수로 사용하는 것을 `부분적용`이라 한다.

## ❓이벤트 버블링이 무엇인지 설명해 주세요.

이벤트는 캡쳐, 타겟, 버블이라는 3개의 단계를 거쳐 흐릅니다. 그 중 버블은 이벤트가 타겟 요소에서 부모 요소들을 거쳐 윈도우까지 전파되는 단계를 말합니다.

**버블링을 막는 방법**

- event.stopPropagation(): 이벤트가 상위 요소로 전파되는 것은 막을 수 있지만, 같은 이벤트를 처리하는 다른 핸들러의 호출은 막지 못합니다.
- event.stopImmediatePropagation(): 이벤트가 상위 요소로 전파되는 것을 막고, 같은 이벤트를 처리하는 다른 핸들러의 호출까지 막습니다.

## ❓이벤트 위임에 대해 설명해 주세요.

이벤트 핸들링이 필요한 요소들의 공통된 상위 요소 하나에 이벤트 핸들러를 달아서 각 하위 요소들의 이벤트 처리를 위임하는 방식을 말합니다.

- 장점
  - 많은 핸들러를 할당하지 않아도 되기 때문에 초기화가 단순해지고 메모리가 절약됩니다.
  - 하위 요소를 추가하거나 제거할 때 해당 요소에 할당된 핸들러를 추가하거나 제거할 필요가 없기 때문에 코드가 짧아집니다.
  - `innerHTML` 등의 스크립트로 요소들을 덩어리 단위로 더하거나 뺄 수 있기 때문에 DOM 수정이 쉬워집니다.
- 단점
  - 이벤트 위임을 사용하려면 이벤트가 반드시 버블링 되어야 하지만 버블링 되지 않는 이벤트가 존재합니다. (load, unload, abort, error, focus, blur, mouseenter, mouseleave)
  - 하위 요소에 할당한 핸들러엔 `event.stopPropagation()`를 쓸 수 없습니다.
  - 상위 요소에 할당된 핸들러가 응답할 필요가 없는 이벤트에도 모든 하위 컨테이너에서 발생하는 이벤트에 응답해야 하므로 CPU 작업 부하가 늘어날 수 있습니다. 하지만 이런 부하는 무시할만한 수준이므로 실제로는 잘 고려하지 않습니다.

## ❓Vite는 왜 빠른가요?

- ### esbuild

  Go로 작성된 Esbuild는 Webpack, Parcel과 같은 기존의 번들러 대비 10-100배 빠릅니다.

- ### 브라우저 네이티브 활용

  Vite는 기본적으로 개별 파일이 모듈로서 동작하는 웹 브라우저의 네이티브 모듈 시스템을 활용합니다. 개별 모듈이 필요한 경우에만 다운로드되고 실행되기 때문에 전체 애플리케이션을 다시 빌드할 필요가 없어져 더 빠른 개발과 로딩 속도를 보장합니다.

  Vite는 애플리케이션의 모듈을 dependencies와 source code 두 가지 카테고리로 나누어 개발 서버의 시작 시간을 개선합니다.

  - Dependencies: 개발 시 그 내용이 바뀌지 않을 일반적인(Plain) JavaScript 소스 코드입니다. 기존 번들러로는 컴포넌트 라이브러리와 같이 몇 백 개의 JavaScript 모듈을 갖고 있는 매우 큰 디펜던시에 대한 번들링 과정이 매우 비효율적이었고 많은 시간을 필요로 했습니다.

  - Source code: JSX, CSS 또는 Vue/Svelte 컴포넌트와 같이 컴파일링이 필요하고, 수정 또한 매우 잦은 Non-plain JavaScript 소스 코드입니다. (물론 이들 역시 특정 시점에서 모두 불러올 필요는 없습니다.)

  vite는 Native ESM을 이용해 소스 코드를 제공합니다. 이것은 본질적으로 브라우저가 번들러의 작업의 일부를 차지할 수 있도록 합니다. vite는 브라우저가 요청하는 대로 소스 코드를 변환하고 제공하기만 하면 됩니다. 조건부 동적 import 이후의 코드는 현재 화면에서 실제로 사용되는 경우에만 처리됩니다.

- ### ESM을 활용한 HMR

  어떤 모듈이 수정되면 vite는 그저 수정된 모듈과 관련된 부분만을 교체할 뿐이고, 브라우저에서 해당 모듈을 요청하면 교체된 모듈을 전달할 뿐입니다. 전 과정에서 완벽하게 ESM을 이용하기에, 앱 사이즈가 커져도 HMR을 포함한 갱신 시간에는 영향을 끼치지 않습니다.

- ### Caching
  또한 vite는 HTTP 헤더를 활용하여 전체 페이지의 로드 속도를 높입니다. 필요에 따라 소스 코드는 304 Not Modified로, 디펜던시는 Cache-Control: max-age=31536000,immutable을 이용해 캐시됩니다. 이렇게 함으로써 요청 횟수를 최소화하여 페이지 로딩을 빠르게 만들어 줍니다.
